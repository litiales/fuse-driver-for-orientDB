\chapter{L'implementazione del filesystem virtuale}

\section{Una vista d'insieme}
\subsection{La struttura del progetto}
Il lavoro che verrà presentato di seguito costituisce non l'intera implementazione del progetto, ma una parte di essa. Per ragioni di complessità, infatti, è stato deciso di dividere il lavoro in due parti distinte e relativamente indipendenti.
Realizzare un driver fuse comporterebbe effettivamente la scrittura del driver vero e proprio, l'implementazione della parte relativa al data storage e la progettazione della comunicazione tra i due strati software.

Come è noto, fuse è una libreria \emph{poliglotta}, nel senso che esistono vari linguaggi che permettono di implementare un driver di questo tipo (C, C++, Java, Python sono tra i più noti), ma, storicamente, quello più usato, e quindi testato, è stato il C; gli altri linguaggi, oltre a non avere una documentazione comparabile a quella disponibile per C, non sono ufficiali, nel senso che sono implementazioni \emph{custom}, con i difetti e le instabilità che questo comporta.

In base a quanto sopra, la scelta del linguaggio con cui realizzare il driver fuse è stata il C. Dall'altra parte, però, si sono presentati problemi opposti: OrientDB è un database \emph{pure Java} e mette a disposizione API native per questo linguaggio. Anche in questo caso, la comunità ha sviluppato dei driver che permettono l'uso di OrientDB anche in altri linguaggi, quali C\#, C++, C, PHP.ettivamente
Il problema che si è presentato è stato sempre lo stesso: questi driver non permettono di sfruttare in pieno le potenzialità di OrientDB, ed inoltre sono troppo recenti per essere considerati una buona base su cui costruire un lavoro importante come questo.

La scelta finale, per entrambi gli \emph{end-point} del lavoro, è stata quella di prediligere i linguaggi nativi. Questo ha comportato la necessità di realizzare un'infrastruttura di comunicazione tra i due linguaggi, e le possibilità analizzate sono state:

\begin{itemize}
\item \emph{JNI} La prima idea è stata quella di usare JNI, acronimo di Java Native Interface. Come viene definita nella documentazione Oracle, e rimarcato anche in quella IBM, la JNI è un'interfaccia di programmazione utilizzata per scrivere metodi nativi ed integrare la Java virtual machine in applicazioni C/C++. Di conseguenza, quello che JNI rende possibile, spiegando è possibile invocare funzioni scritte in C e C++ da Java, e viceversa.
La maggiore difficoltà che avrebbe comportato questa scelta sarebbe stata la compatibilità cone le varie JVM. L'interfaccia JNI, infatti, andando a lavorare a basso livello, non è uno standard, ma è legata alla singola implementazione, e l'uso di diverse JVM avrebbe comportato la potenziale non compatibilità, rendendo vano l'impegno.
Oltre a ciò, la documentazione ufficiale è aggiornata alla versione 1.2 di Java.
\item \emph{Socket} In un secondo momento è stato ipotizzato l'uso delle socket e del framework \emph{zeromq}, così da semplificare lo svilupppo; il motivo per cui questa idea è stata abbandonata consiste nelle difficoltà intrinseche dell'uso delle socket per applicazioni così varie: si sarebbe reso necessario creare un protocollo di comunicazione client-server, e fare ciò in maniera efficiente avrebbbe richiesto un imponente sforzo, oltre che la fase di debug dell'applicazione si sarebbe complicata e non sarebbe stato possibile ampliare il lavoro in futuro senza grossi sforzi.
\item \emph{Web service Rest} Infine si è arrivati alla scelta di creare un web service Rest per la comunicazione client-server. Ciò permette di non costringere i futuri manutentori del software a modifiche sostanziali, ma a limitarsi allo strato necessario. Infatti utilizzando questa tecnologia è possibile riconoscere nell'architettura complessiva del progetto tre \emph{layer} distinti: il client-driver, lo strato comunicazione e lo strato storage. Inoltre è possibile, con un minimo sforzo, ampliare i servizi offerti da fuse\footnote{Si pensi, ad esempio, alla semplicità con cui sarebbe possibile creare un'interfaccia web per la gestione del filesystem in un ambiente su cui non sia disponibile fuse.}.
\end{itemize}
Quello che viene trattato in questo lavoro è la parte relativa al data storage, ovvero al terzo ed ultimo strato software.
Nei paragrafi che seguono verranno analizati nel dettaglio i componenti ed il funzionamento di questo layer, a partire dal linguaggio utilizzato per interrogare il database.
\subsection{Le API Blueprints}
L'autore del testo ha deciso di iniziare l'analisi del data-storage dalla tecnologia utilizzata concretamente per interfacciarsi con il database. Come abbiamo visto nel capitolo precedente, OrientDB può essere utilizzato in due modalità: a grafo o documentale; la struttura che più si presta all'implementazione di un filesystem virtuale, naturalmente, è la prima.

Una differenza sostanziale tra un database relazionale ed un database non relazionale consiste nel modo in cui questo può essere interrogato: nel primo caso abbiamo a disposizione l'SQL, ovvero un linguaggio dichiarativo multidatabase, utilizzabile sia da riga di comando, sia da applicazione (tramite l'uso di specifici driver). Nel secondo caso, invece, non è possibile trovare un linguaggio multidatabase standardizzato, ma ciascun produttore offre delle proprie API, e queste sono strettamente legate al prodotto in questione. Nel caso di OrientDB, come abbiamo accennato, le API sono disponibili in Java; sono inoltre disponibili porting non ufficiali anche per altri linguaggi. 

Lavorare a livello database è però inefficiente dal punto di vista del \emph{throuhput}, in quanto è necessario gestire molti fattori, come la cache, l'uso di transazioni o le indicizzazioni.

Quali sono allora i vantaggi di usare OrientDB? Il vantaggio consiste dal poter usufruire della combinazione di OrientDB e dello stack Tinkerpop. Quest'ultimo, come viene definito dal sito del produttore, è uno stack open-source, Java oriented, per il panorama emergente dei grafi; esso fornisce le basi per costruire applicazioni ad alte performance di qualsiasi dimensione che operino su grafi, e sono in grado di scalare da una semplice modellazione dei dati, fino a gestire grafi da un trilione di nodi distribuiti su un cluster di computer. In particolare Tinkerpop è costituito da:
\begin{itemize}
\item \emph{Blueprints} offre un'interfaccia verso il modello a grafi per i database con delle implementazioni già realizzate.
\item \emph{Pipes} è un framework che permette il controllo del flusso dei dati, dall'input all'output.
\item \emph{Gremlin} è un linguaggio specifico per effettuare il \emph{traversing} dei grafi.
\item \emph {Frames} permette di lavorare con gli oggetti Blueprints come fossero degli ogggetti Java, nascondendo il fatto che in realtà si sta operando con nodi e vertici.
\item \emph{Furnace} fornisce degli algoritmi specifici per lavorare con i grafi.
\item \emph{Rexster} è un server multi protocollo, con particolare attenzione a Rest, che espone i database che implementano Blueprints.
\end{itemize}
La scelta di Blueprints, e, quindi, di Tinkerpop, è stata effettuata principalmente basandosi sul criterio fondamentale della \emph{modularità} dell'applicazione. L'implementazione dell'interfaccia Blueprints da parte di OrientDB rimane totalmente isolata al programmatore, che potrà quindi concentrarsi più sul proprio codice e sfruttare al meglio le potenzialità offerte dallo storage sottostante, con la sicurezza che eventuali bug o problemi di performance verranno risolti in maniera trasparente.

Un esempio che aiuterà a comprendere come l'uso di Blueprints aiuti il programmatore a pensare al cosa piuttosto che al come deriva dalla nuova\footnote{Ci si riferisce alla release del 7/6/2013} implementazione fornita da OrientDB; quando si desidera creare un nuovo \emph{edge} tra due vertici senza che però esso stesso debba memorizzare informazioni, utilizzando le \emph{raw} API si hanno due possibilità: creare un vero edge, comportando la creazione di un ODocument\footnote{L'elemento utilizzato da OrientDB per memorizzare i dati} vuoto, che comunque occupa spazio in memoria e richiede, nella fase di traversing, di caricare il record in questione, o memorizzare come campo del vertice \emph{parent} un collegamento diretto ad esso. Naturalmente la prima soluzione appare più semplice da realizzare e manutenere nel tempo, seppur si riveli la più inefficiente a causa dell'inutile caricamento da disco di un record non necessario, mentre la seconda, seppur ottimale, risulta essere la più complessa da implementare, per via della macchinosità della soluzione trovata. OrientDB nell'implementazione dell'interfaccia Blueprints risolve il problema introducendo il concetto di \emph{lightweight edge}, ovvero archi leggeri, senza campi di informazioni proprie; se la creazione richiesta è per un lightway edge allora automaticamente viene usata la seconda strategia, mentre se l'arco ha informazioni viene creato un documento. Tutto ciò viene fatto in automatico dal sistema, senza richiedere l'intervento del programmatore, che così si concentra sul cosa (creazione dell'arco), e non sul come (adottare la prima o la seconda strategia).

Oltre a ciò non va trascurato il fatto che Blueprints, così come tutto lo stack Tinkerpop, è multipiattaforma: lo stesso codice utilizzato per costruire e modellare il virtual filesystem su base OrientDB, con piccole modifiche, può essere utilizzato su altri database che implementano questa interfaccia (come ad esempio Neo4j o MongoDB\footnote{Anche se MongoDB non è un database a grafi gli sviluppatori hanno comunque dato un'implementazione dell'interfaccia Blueprints tale da simularne un comportamento}).

La flessibilità della scelta si dimostra anche nel momento in cui si dovesse rendere necessario scendere ad un maggior livello di dettaglio nell'uso del database: Blueprints offre la possibilità di ottenere il database a basso livello, come nel caso si necessiti di \emph{tuning} del sistema (gestione della cache, accesso ad eventuali indici) o, più semplicemente, nel caso in cui si debbano usare delle funzionalità che Blueprints non offre\footnote{Ad esempio Blueprints non prevede la presenza di una root. Questo comportamento deriva dal fatto che esistono due distinte correnti riguardo la gestione dei database a grafo: i produttori che considerano la root un elemento essenziale del grafo, e quelli che eliminano questo concetto. Essendo Blueprints un framework trasversale, necessita di essere quanto più possibile generico, e quindi non può offrire funzionalità che poi non tutti i produttori sono in grado di offrire. Attualmente OrientDB utilizza un approccio libero, ovvero se si vuole è possibile creare una o più root ed assegnare loro un nome, così da facilitarne il recupero.}.

\section{Il filesystem virtuale}
In questa sezione sarà analizzata l'implementazione del filesystem virtuale, analizzando le scelte e le strategie adottate, mentre i test saranno discussi nel capitolo che segue.
Tutto il codice qui discusso è disponibile alla pagina internet \emph{http://github.com/litiales/fuse-driver-for-orientDB/tree/master/OVirtualFileSystem}
Gli argomento trattati saranno discussi seguento questo ordine:
\begin{itemize}
\item \emph{Creazione ed apertura del filesystem}
\item \emph{La rappresentazione dei dati}
\item \emph{Gestione dei permessi}
\item \emph{Data browsing}
\item \emph{Funzioni sul filesystem}
\end{itemize}

\subsection{Creazione ed apertura del filesystem}
Fondamentale per poter operare con ogni filesystem è poterne eseguire un \emph{mount}, operazione che, come si può apprendere eseguendo il comando \emph{man mount}, consiste nel rendere disponibile in una directory specificata dall'utente i file contenuti in esso. 
Questo significa che, al momento in cui un utente richiederà di accedere al suo filesystem il sistema deve essere in grado di convertire i file di storage che abbiamo visto al Capitolo 2 in un qualcosa che abbia senso e che sia concretamente disponibile.

Per soddisfare questa richiesta, è presente la classe \emph{OVFSManager}: la sua implementazione è piuttosto semplice, in quanto è costituita da funzioni di gestione primitiva del database, quali l'apertura e/o la creazione, la chiusura e l'eliminazione. Accanto ad esse troviamo degli atributi che contengono tutto il necessario per operare poi concretamente con il filesystem.

Il costruttore della classe è un accessibile solo attraverso metodi statici in quanto OrientDB prevede la possibilità di specificare un path specifico per il salvataggio del database, oltre che la possibilità di specificare un utente ed una password specifici, ed a seconda delle necessità dell'utente verrà richiamata la funzione adatta. In effetti tutte e quattro le funzioni fanno poi una chiamata allo stesso costruttore, passando parametri standard o personalizzati, restituendo una istanza della classe. Va sottolineato come il sistema sottostante debba mantenere in memoria una sola istanza della classe per ciascun database aperto, in quanto l'uso embedded di OrientDB non prevede la sincronizzazione tra processi concorrenti, la richiesta di riapertura di uno stesso filesystem comporterebbe degli errori di consistenza. Questo è il caso in cui due o più utenti richiedano il mount per uno stesso filesystem: il sistema dovrà occuparsi di gestire le richieste accedende sempre e solo alla stessa istanza di OVFSManager, mentre se la richiesta è per filesystem diversi non ci sono problemi, sarà possibile gestire più istanze simultaneamente.

Un'ulteriore caratteristica di questa classe è la capacità di gestire una prima apertura del database come se già esistesse, ovvero il sistema non ha il compito di controllare l'esistenza di uno specifico filesystem: se il filesystem esiste verrà aperto, altrimenti verrà creato usando i parametri specificati e poi aperto.

\subsection {La rappresentazione dei dati}
Sicuramente la parte più significativa da un punto di vista implementativo è il modello della rappresentazione dei dati: scegliere una rappresentazione corretta significa semplicità nella scrittura delle funzioni e minor tasso di errori, scegliere una rappresentazione complessa significa rendere complessa, se non impossibile, l'aggiunta di funzionalità.

Per definire il modello dei dati adottato in questa implementazione è stata seguita la rappresentazione ad alto livello di un qualunque filesystem. Questo significa che, mentre normalmente vengono usati gli \emph{inode} a cui sono collegati i blocchi dati, questo filesystem lavora \emph{nativamente} con una struttura a grafo.

Capire il perchè e quali vantaggi/svantaggi questo modelli comporti si pensi che quando si richiede una risorsa ad un filesystem si chiede in realtà all'inode corrispondente di caricare i dati effettivi: abbiamo così un doppio livello di memorizzazione, il livello degli inode ed il livello fisico dei bit memorizzati, proprio come in una qualsiasi implementazione di filesystem in un database relazionale in cui non è possibile avere dati strutturati. Il problema in OrientDB non sussiste, essendo possibile definire un grafo. Effettivamente questa scelta potrebbe comportare problemi di performance, in quanto per poter attraversare un nodo sarebbe necessario caricare l'intero record, magari contenente centinaia di byte; l'implementazione non comporta questo genere di problemi, in quanto implementa un meccanismo di lazy loading, ovvero un record viene effettivamente caricato solo quando necessario, e non al suo accesso. Abbiamo quindi un meccanismo analogo a quello degli inode e dei blocchi di dati, senza però che siano implementate effettivamente due strutture separate.

 La rappresentazione scelta è stata dunque quella di far equivalere una qualsiasi risorsa, sia essa un link, una directory od un file, ad un vertice del grafo. Per permettere poi la consistenza dei dati, viene creato, al momento dell'inizializzazione del database, un nodo \emph{root} che non può essere eliminato, e che consente l'accesso al filesystem da un unico punto, semplificando la navigazione. Oltre ciò, sfruttando la possibilità di dare a ciascun nodo una label, è possibile conoscere in tempo O(1) il tipo di risorsa che si sta trattando, sia essa una Directory, un File od un Link.
 
 Definite le risorse, è possibile stabilire una gerarchia su di esse, ovvero dei collegamenti che definiscono come il filesystem è articolato. Per ottenere ciò è stato utilizzata la creazione di archi leggeri, che non occupano spazio in memoria, e che richiedono un tempo di attraversamento costante. La strategia adottata è la seguente: si supponga di avere una directory \emph{Dir}, e di voler creare in essa il file \emph{file}; una volta creati i due nodi si crea un arco leggero uscente da \emph{Dir} ed entrante in \emph{file}, con label il nome del file. Analogamente si supponga di avere una risorsa \emph{Resource} e di volerla linkare al link \emph{link}; una volta create le due risorse è sufficiente creare un arco uscente da \emph{linkedRes} ed entrante in \emph{resource} con label \emph{link}. Con questa rappresentazione, dato un path, sarà possibile navigare il filesystem in tempo costante dal momento che non è possibile avere due risorse in una stessa directory con lo stesso nome e quindi l'attraversamento di ciascun arco avrà costo O(1).
 
 \subsection{La gestione dei permessi}
 Tutti i filesystem più recenti dispongono della possibilità di gestire i permessi di una risorsa, ovvero cosa un utente può o non può fare. Nell'implementazione classica di Unix a ciascun file o cartella è associato un permesso, costituito da un numero ottale a tre cifre: da sinistra verso destra le cifre codificano rispettivamente i permessi sulla risorsa assegnati all'utente proprietario, agli utenti appartenenti allo stesso gruppo del proprietario ed a tutti gli altri utenti. Essendo la rappresentazione numerica di tipo ottale, ciascuna cifra viene a sua volta codificata da tre bit, che, da sinistra verso destra, se impostati ad uno, esprimono la possibilità di scrittura, lettura o esecuzione.
 
 Una tale gestione delle risorse è stata ritenuta fondamentale per permettere la scalabilità del filesystem: nel momento in cui si debba condividere le risorse tra più utenti, si rende necessario stabilire una policy su cosa e come si possa fare. Supponiamo che Alice voglia condividere con gli utenti un file importante, ma che voglia esser certa che tale file non venga modificato; se non fosse possibile stabilire delle limitazioni, Bob potrebbe prendere il file ed aggiungere o eliminare dati importanti. Così facendo, invece, basta che Alice imposti come permessi su file, ad esempio, 0744, così chiunque può leggere il contenuto del file, ma nessuno, se non Alice stessa, può modificarlo.
 
 Purtroppo però la gestione dei permessi in un filesystem non condiviso è lasciata al fatto che, almeno teoricamente, i permessi da superutente possa averli solo l'amministratore del sistema, che può fare tutto con i file, senza limitazione alcuna. Questo meccanismo viene meno nel caso in cui si decida di condividere lo stesso filesystem tra più utenti senza che esista una password da amministratore: potenzialmente si lascia a chiunque la possibilità di agire da superutente, proprio come se tutti fossero presenti nel file \emph{sudoers}\footnote{Il file in Unix contiene la lista degli utenti che possono usare la loro password per accedere temporaneamente come amministratori attraverso il comando \emph{sudo}}. Questa scelta implementativa è stata fatta in quanto si suppone che gli utenti che accedono al filesystem siano utenti fidati, e che non abbino quindi intenzioni malevole\footnote{Come viene riportato al primo comando sudo in ArchLinux \emph{"Da grandi poteri derivano granbdi responsabilità}}.
 
 Nell'implementazione del filesystem virtuale i permessi sono rappresentati come una stringa di quattro caratteri che codifica il numero ottale (il primo carattere è uno 0), ed è salvata nel campo \emph{mode} dei nodi (nel caso dei Link, così come in Unix, i permessi su di essi sono gli stessi di quelli delle risorse linkate). La gestione dei permessi è effettuata dalla classe ModeManager, una classe con un unico costruttore privato (così da rendere impossibile crearne un'istanza) in cui tutti i metodi sono statici; così facendo si garantisce che la stessa classe viene condivisa tra più istanze di filesystem, risparmiando spazio in memoria.
 
 Sarà ora presentato lo pseudocodice delle funzioni, ma essendo il codice autoesplicativo ci si limiterà a questo.   
\begin{algorithm}
\caption{La funzione fondamentale per il controllo dei permessi}
\begin{algorithmic}[5]
\Function{getPermission}{resource, user, group}
\State $uOwn\gets resource.get(owner)$
\State $uGroup\gets resource.get(group)$
\State $mode\gets resource.get(mode)$
\If {$uOwn=user$ and $uGroup=group$}
	\State \Return $mode.substr(1,2)$
\ElsIf {$uOwn<>user$ and $uGroup=group$}
	\State \Return $mode.substr(2,3)$
\Else
	\State \Return $mode.substr(3,4)$
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{La funzione che verifica se si hanno permessi in scrittura}
\begin{algorithmic}[5]
\Function{canWrite}{resource, user, group}
\If {$user=root$ and $group=root$}
	\State \Return true
\EndIf
\State $perm \gets getPermission(resource, user, group)$
\If {$perm=2$ or $perm=3$ or $perm=6$ or $perm=7$}
	\State \Return true
\EndIf
\State \Return false
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{La funzione che verifica se si hanno permessi in lettura}
\begin{algorithmic}[5]
\Function{canRead}{resource, user, group}
\If {$user=root$ and $group=root$}
	\State \Return true
\EndIf
\State $perm \gets getPermission(resource, user, group)$
\If {$perm > 3$}
	\State \Return true
\EndIf
\State \Return false
\EndFunction
\end{algorithmic}
\end{algorithm}
   \begin{algorithm}
\caption{La funzione che verifica se si hanno permessi in esecuzione}
\begin{algorithmic}[5]
\Function{canExecute}{resource, user, group}
\If {$user=root$ and $group=root$}
	\State \Return true
\EndIf
\State $perm \gets getPermission(resource, user, group)$
\If {$perm \% 2 = 1$}
	\State \Return true
\EndIf
\State \Return false
\EndFunction
\end{algorithmic}
\end{algorithm}
\subsection{Data browsing}
Come già sottolineato, montare un filesystem significa costruire un albero, ovvero stabilire una gerarchia tra risorse, ed operare su un filesystem si riduce a due operazione fondamentali: navigare il filesystem fino alla risorsa desiderata per poi operare effettivamente.

Risulta quindi necessario avere un meccanismo sicuro ed efficiente che permette di effettuare il \emph{browsing} del tree, altrimenti qualsiasi implementazione ottima al momento dell'operazione viene vanificata. La struttura che è stata data filesystem è già stata analizzata due paragrafi fa e non verrà ritrattata in questo luogo. Quello che sarà invece approfondito è il come questa struttura viene sfruttata dalla classe ODatabaseBrowser. 

Questa classe ha un attributo in cui è memorizzata la root del filesystem, e tre metodi, di cui uno privato e due visibili solo all'interno del package, oltre ad un quarto metodo pubblico che elenca tutte le risorse del filesystem, utile in fase di testing. 

La funzioni privata \emph{getParentResource} viene richiamata dalle altre due funzioni, ed è quella che effettua il browsing, restituendo la risorsa che precede quella specificata nel path; ad esempio, si supponga di richiedere una certa operazione da effettuare sulla risorsa \emph{/home/user/resource}, verrà restituita la risorsa padre, ovvero \emph{/home/user/}. Man mano che dalla root scende verso le foglie questa funzione verifica di avere i permessi per poter continuare, permessi che nella comune implementazione Unix sono d'esecuzione, oltre che la risorsa corrente esista e sia effettivamente una Directory. Come parametri d'ingresso richiede un array dove è presente la lista ordinata delle risorse da attraversare per restituire il padre, una variabile dove inserire un eventuale codice di errore, e le credenziali dell'utente.

Si passa ora alle funzione che vengono usate all'interno del codice, e che fanno riferimento alla funzione precedente. La prima è la \emph{getResourcePath}, che viene invocata nel caso si voglia creare una nuova risorsa: in questo caso si prende la risorsa che viene restituita da \emph{getResource}, e si controlla che essa non sia nulla; se poi il nodo non contiene altri vertici uscenti con il nome della risorsa che si vuole creare allora viene ritornato, altrimeni la funziona ha un return nullo. Di seguito è riportato lo pseudocodice:

Per finire è presente la funzione utilizzata dalla maggior parte delle funzioni, la \emph{getResource}, che restituisce il vertice specificato nel path, o null se l'elaborazione ha incontrato problemi. Come funzione è abbastanza elementare, semplicemente chiama la \emph{getParentresource}, verifica se l'utente ha i permessi d'esecuzione sulla directory padre, se si tenta di restituire la risorsa richiesta se questa è presente. In caso di errori restituisce null.

\begin{algorithm}
\caption{La funzione fondamentale del data browsing}
\begin{algorithmic}[5]
\Function{getParentResource}{path, retValue, user, group}
	\If {$path.length=1$}
		\State $retValue.value \gets EACCESS$
		\State \Return $null$
	\EndIf
	\State $index \gets 1$
	\State $parent \gets root$
	\While {$index+1 < path.leght$ and $parent<>null$}
		\If {$canExecute(parent, user, group)$}
			\State $retValue.value \gets EACCESS$
			\State \Return null
		\EndIf
		\State $parent \gets parent.follow(path[index])$
		\If {$parent=null$}
			\State $retValue.value \gets ENOENT$
		\ElsIf {parent.isNotDirectory}
			\State $retValue.value \gets ENOENT$
			\State $parent \gets null$
		\EndIf
		\State $index++$
	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{La funzione che ritorna il padre di una risorsa}
\begin{algorithmic}[5]
\Function{getResourcePath}{path, retValue, user, group}
	\State $canonicalPath \gets path.split("/")$
	\State $parent \gets getParentResource(canonicalPath, retValue, user, group)$
	\If {$parent=null$}
		\State \Return null
	\EndIf
	\State $resourceName \gets canonicalPath.lastElement$
	\If {$parent.hasOutResource(resourceName)=false$}
		\State \Return parent
	\EndIf
	\State $retValue.value \gets EEXIST$
	\State \Return null
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione che ritorna una risorsa}
\Function{getResource}{path, retValue, user, group}
	\State $canonicalPath \gets path.split("/")$
	\State $parent \gets getParentResource(canonicalPath, retValue, user, group)$
	\If {$parent=null$}
		\State \Return null
	\EndIf
	\If {$canExecute(parent, user, group)=false$}
	\State $retValue.value \gets EACCESS$
		\State \Return null
	\EndIf
	\State $resourceName \gets canonicalPath.lastElement$
	\State $resource \gets parent.follow(resourceName)$
	\If {$resource = null$}
		\State $retValue.value \gets ENOENT$
		\State \Return null
	\EndIf
	\State \Return resource
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage

\subsection{Funzioni sul filesystem}
Verranno ora analizzate le funzioni che vanno ad operare materialmente sul database, seguite dalla loro implementazione in pseudocodice. Tutte loro operano sul database simulando il comportamento abituale di un filesystem, e sono state ispirate dal set di funzioni implementate da fuse. Un'ulteriore caratteristica da evidenziare è l'atomicità delle operazioni, che vengono commissionate al database solo alla fine, e mai passo passo, permettendo il \emph{rollback} ad uno stato sicuro in caso di errore.

Nelle funzioni che richiedono un valore di ritorno diverso da quello indicante il risultato dell'operazione (ad esempio nel caso della read che ritorna un array di byte), poichè in Java non è previsto il passaggio di parametri per riferimento si è reso necessario l'uso di istanze della classe \emph{IntWrapper}, che contengono al loro interno un valore intero che, se settato, indica un errore\footnote{Infatti in Java seppur è vero che l'unico passaggio di parametri previsto è quello per valore, non bisogna dimenticare che, nel caso di oggetti, il valore passato non è l'oggetto in sè, quanto piuttosto il riferimento all'oggetto; quindi in un metodo non è possibile, ad esempio scambiare due o più oggetti passati come parametri, perchè significherebbe modificare i loro riferimenti, ma risulta possibile modificare i loro attributi.}.

\subsubsection{Creazione di risorse}
La funzione principale di cui un filesystem deve disporre è quella che permette la creazione di nuove risorse, siano esse file o directory (i link verranno trattati più avanti). 

Senza di essa un filesystem sarebbe statico, e nessun utente avrebbe interesse nell'usarlo. Per implementare questa funzionalità basilare è stata implementato il metodo \emph{create\_resource}, che richiede come parametri il path completo della risorsa da creare, i suoi permessi, le sue credenziali (nome utente e gruppo) ed il tipo di risorsa da creare.

Il metodo non permette di creare una risorsa che si trovi gerarchicamente alla pari della root, per evitare di avere un filesystem con più di una radice, e parimenti non permette ad una risorsa file di avere un nome terminante con uno slash, dal momento che tale terminazione è associata alle directory.

Al suo interno, come abbiamo visto nel capitolo relativo al data browser, fa uno della funzione \emph{getResourcePath}, che restituisce l'elemento che accoglierà la nuova risorsa nel caso in cui l'utente abbia i permessi di esecuzione e scrittura su di esso. Il passo successivo è creare il nuovo vertice, inizializzarlo con i dati specificati dall'utente e collegarlo alla risorsa padre, di cui vengono aggiornati i tempi di modifica e cambiamento (mtime e ctime).

Poichè la funzione di creazione viene richiamata non solo per una semplice creazione di risorsa, ma anche nell'ambito di un più complesso flusso di esecuzione (come la write su una risorsa non esistente), è stato impostato un flag binario che specifica se, al termine dell'esecuzione, il database deve commissionare la transazione oppure attendere perchè la sua conclusione sarà compito del metodo invocante.
\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funziona che crea directory e file}
\Function{create\_resource}{path, mode, user, group, type, commit}
	\If {$path="/"$}
		\State \Return EPERM
	\EndIf
	\If {$type.isNotLink$ and $type.isNotDirectory$}
		\State \Return EINVAL
	\EndIf
	\State $retVal \gets new IntWrapper()$
	\State $parent \gets getResourcePath(path, retValue, user, group)$
	\If {$parent=null$}
		\State \Return retValue.value
	\EndIf
	\If {$canExecute(parent, user, group)$ and $canWrite(parent, user, group)$}
		\State $parent.ctime \gets now$
		\State $parent.mtime \gets now$
		\State $resName \gets path.getResName$
		\State $resource \gets initializeResource(mode, user, group, resName)$
		\State $parent.addOutEdge(resource, resName)$
		\If {$commit = true$}
			\State $database.commit$
		\EndIf
	\Else
		\State \Return EPERM
	\EndIf
	\State \Return 0
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Link a risorse}
Un'ulteriore risorsa standard dei filesystem Unix è il link, ovvero un collegamento ad una risorsa che può essere di due tipi: logico, e si ha un \emph{soft link}, noto anche come \emph{symbolic link} o fisico, noto come \emph{hard link}. Un link simbolico, come riportato dall'Università dell'Indiana, %alla pagina internet \emph{http://kb.iu.edu/data/abbe.html}
è un tipo speciale di risorsa che punta ad un'altra risorsa, proprio come gli \emph{shortcut} in Windows, e a differenza degli hard link non contiene dati, ma semplicemente punta un'altra risorsa del filesystem; questo è particolarmente evidente al momento dell'eliminazione della risorsa linkata, infatti in questo caso il link simbolico diventa inusabile, mentre l'hard link continua ad avere i dati memorizzati. Inoltre, poichè non linka dei blocchi di dati, ma un inode, è possibile collegargli non solo file, ma anche directory e risorse su computer remoti (ma questa opportunità non è stata affrontata).

Ciò detto, la realizzazione dei link in questo filesystem è stata compiuta effettundo una scelta, ossia l'implementazione dei soli soft link, dal momento che gli hard link avrebbero comportato l'aumento della complessità del sistema globale senza fornire funzionalità aggiuntive significative; infattti, come è già stato accennato, il modello prevede la distinzione tra inode e blocchi di dati, ma questa distinzione è in realtà logica, in quanto entrambi si trovano sullo stesso record, ma su due livelli differenti: l'inode può essere identificato come il record in astratto, ovvero come punto di passaggio, mentre i dati e le informazioni vengono salvate nel record vero e proprio.

L'algoritmo di creazione dei link richiede come parametri di ingresso il path del il link e quello della risorsa linkata e le credenziali dell'utente, e restituisce il valore corrispondente allo stato dell'operazione. Inizialmente, come per la creazione di un file o di una directory, viene richiesto il vertice sotto cui creare il link, se si hanno su di esso permessi di esecuzione e scrittura allora viene richiesto anche il vertice corrispondente alla risorsa da linkare; viene inizializzata una nuova risorsa con label \emph{Link} ed i parametri stabiliti dall'utente. Infine viene creato un arco tra la risorsa padre (a cui vengono aggiornati i tempi mtime e ctime) ed il link, oltre che tra il link stesso e la risorsa linkata (a cui viene aggiornato il tempo ctime). 

Al termine di questa operazione l'albero iniziale si trasforma in un grafo.

\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione che crea un link ad una risorsa}
\Function{link}{linkPath, linkedResource, user, group}
	\If {$linkPath="/"$}
		\State \Return EPERM
	\EndIf
	\State $retValue \gets new IntWrapper()$
	\State $linkParent \gets getResourcePath(linkPath, retValue, user, group)$
	\If {$linkParent=null$}
		\State \Return retValue.value
	\EndIf
	\If {$canExecute(linkParent, user, group)=false$ or $canWrite(linkParent, user, group)=false$}
		\State \Return EPERM
	\EndIf
	\State $linked \gets getResource(linkedResource, retValue, user, group)$
	\If {$linked=null$}
		\State \Return retValue.value
	\EndIf
	\State $linkName \gets linkPath.getResName$
	\State $link \gets initializeNewLink(linkParent, linked, linkName, linkedResource)$
	\State $linkParent.addOutEdge(link, linkName)$
	\State $link.getOutEdge(linked, "link")$
	\State $linked.ctime \gets now$
	\State $linkParent.ctime \gets now$
	\State $linkParent.mtime \gets now$
	\State \Return 0
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage

\subsubsection{Il follow dei link}
Come detto sopra, creare un link significa creare una risorsa che punta ad un altra risorsa; si rende quindi indispensabile avere una metodo che, dato un link, sia in grado di dire qual è la risorsa ad esso collegata (può ancora trattarsi di un link, o non avere risorse linkate nel caso esse siano state eliminate).

Per fare ciò è presente il metodo readlink, che richiede il path del link e le credenziali dell'utente, e restituisce la stringa contenente il path della risorsa collegata, ed in caso di errore setta un errore. Fondamentalmente la funzione chiede al data browser il vertice corrispondente alla risorsa richiesta, verifica che sia un link, e restituisce il path per del vertice ad esso collegato.

\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione che effettua il follow dei link}
\Function{readLink}{path, retValue, user, group}
	\State $link \gets getResource(path, retValue, user, group)$
	\If {$link=null$}
		\State \Return null
	\EndIf
	\If {$link.isNotLink$}
		\State $retValue.value \gets EINVAL$
		\State \Return null
	\EndIf
	\Return link.linkedPath
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Le informazioni sulle risorse}
La funzione gettatr permette di ottenere un set di informazioni su uno specifico nodo. Un tipico esempio di quando questa funzione viene richiamata è quello in cui l'utente richiede da terminale di eseguire il comando \emph{stat} su una risorsa. Le informazioni restituite dalla funzione sono i permessi, lo username ed il gruppo del possessore della risorsa, la sua dimensione, l'ultimo tempo di accesso, di modifica e di cambiamento ed il tipo di risorsa.

Poichè Java non permette la restituzione di valori multipli come la funzione richiederebbe, è stata usata la classe \emph{Stat} avente come attributi privati tutti i campi di interesse che sono accessibili tramite dei \emph{getter} pubblici (così da garantire l'integrità dei dati).

La procedura eseguita da getattr è abbastanza semplice: richiede al data browser la risorsa specificata nel path, se è presente controlla che non sia un link, in caso negativo segue la risorsa da essa linkata in maniera ricorsiva fino ad arrivare ad un file o ad una directory. Poichè un link può anche essere interrotto, questa eventualità viene gestita restituendo \emph{null}, poichè non è stato possibile determinare la risorsa su cui eseguire lo stat. Infine viene creata un oggetto Stat con i parametri corretti e viene restituito.
\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione che restituisce i metadati di una risorsa}
\Function{getattr}{path, retValue, user, group}
	\State $resource \gets getResource(path, retValue, user, group)$
	\If {$resource=null$}
		\State \Return null
	\EndIf
	\If {$resource.isLink$}
		\State $resource \gets resource.followLinks$
	\EndIf
	\If {$resource.isLink$}
		\State $retValue.value \gets ENOENT$
		\State \Return null
	\EndIf
	\State \Return new Stat(resource.mode, resource.user, resource.group, resource.size, resource.atime, resource.ctime, resource.mtime, resource.type)
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{La rimozione di risorse}
Operazione importante tanto quanto la creazione di nuove risorse è la loro rimozione, senza la quale un filesystem verrebbe rapidamente saturato, e non potrebbe mai essere ordinato. In Unix sono previsti due tipi di romozione di risorse, accessibili tramite system call diverse, la \emph{unlink}, che permette la rimozione di file e link, e la \emph{rmdir}, che permette la rimozione di directory vuote. 

La rimozione di un file o di un link prevede che l'utente abbia i permessi di scrittura sulla risorsa in questione, e quelli in scrittura ed esecuzione sulla cartella al livello superiore; il metodo inizia richiedendo il vertice corrispondente all risorsa richiesta, da questa, se non è una directory, viene presa la risorsa padre, e se verificano i permessi. Se la risorsa da eliminare è un file vengono eliminati tutti i dati a lui relativi, infine si procede alla rimozione di tutti gli archi uscenti o entranti e, quindi, del vertice stesso. Vengono poi aggiornati i tempi di cambiamento e modifica della risorsa padre.

Analogo meccanismo è seguito dal metodo che gestisce la rimozione delle cartelle, con l'unica differenza che il controllo deve confermare che si sta tentando di eliminare una directory e che essa non sia vuota.

\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione di rimozione di file e link}
\Function{remmoveResource}{path, user, group}
	\State $retValue \gets new IntWrapper()$
	\State $resource \gets getResource(path, retValue, user, group)$
	\If {$resource=null$}
		\State \Return retvalue.value
	\EndIf
	\If {$resource.isDirectory$}
		\State \Return EISDIR
	\EndIf
	\State $parent \gets resource.getParent$
	\If {$canWrite(parent, user, group)=false$ or $canWrite(resource, user, group)=false$}
		\State \Return EPERM
	\EndIf
	\If {$resource.isFile$}
		\State $resource.removeData$
	\EndIf
	\State $resource.removeEdge$
	\State $resource.delete$
	\State $parent.ctime \gets now$
	\State $parent.mtime \gets now$
	\State \Return 0
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage

\begin{algorithm}
\begin{algorithmic}[5]
\caption{la funzione di rimozione delle directory}
\Function{removeDirectory}{path, user, group}
	\State $retValue \gets new IntWrapper()$
	\State $resource \gets getResource(path, retValue, user, group)$
	\If {$resource=null$}
		\State \Return retvalue.value
	\EndIf
	\If {$resource.isNotDirectory$}
		\State \Return ENOTDIR
	\EndIf
	\State $parent \gets resource.getParent$
	\If {$canWrite(parent, user, group)=false$ or $canWrite(resource, user, group)=false$}
		\State \Return EPERM
	\EndIf
	\If {$resource.isNotEmpty$}
		\State \Return ENOTEMPTY
	\EndIf
	\State $resource.removeEdge$
	\State $resource.delete$
	\State $parent.ctime \gets now$
	\State $parent.mtime \gets now$
	\State \Return 0
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Il rename delle risorse}
Nel sistemi Unix è possibile rinominare una risorsa attraverso la system call \emph{rename}, che richiede i permessi ; un'analoga funzione è stata implementata nel filesystem virtuale.

In realtà la rename effettua un'operazione ben più complessa di quello che ci si aspetterebbe; se infatti il nuovo nome che si vuole assegnare alla risorsa esiste già nella directory corrente allora il filesystem tenta di sovrascrivere la seconda con la prima, seguendo la seguente politica:
\begin {itemize}
\item se la risorsa da rinominare è una directory allora quella che deve essere sovrascritta deve essere a sua volta una directory;
\item se la risorsa da rinominare non è una directory allora non può essere sovrascritta una risorsa che sia una directory;
\item infine se la risorsa da rinominare è una directory e quella che deve essere sovrascritta è non vuota allora non è possibile portare a termine l'operazione.
\end{itemize}
Oltre a ciò, la ridenominazione offre anche il supporto allo spostamento del file, proprio come il comando \emph{mv}. L'operazione di \emph{rename} comporta inoltre l'aggiornamento dei tempi di modifica e cambiamento delle due risorse padre, e del solo tempo di cambiamento per quella rinominata.
\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione di rename}
\Function{rename}{path, newPath, user, group}
	\State $retValue \gets new IntWrapper()$
	\State $resource \gets getResource(path, retValue, user, group)$
	\If {$resource=null$}
		\State \Return retValue.value
	\EndIf
	\State $parent \gets resource.getParent$
	\If {$canWrite(parent, user, group)=false$}
		\State \Return EPERM
	\EndIf
	\State $newParent \gets getResourcePath(path, retValue, user, group)$
	\If {$newParent=null$}
		\State \Return retValue.value
	\EndIf
	\If {$newParent.isNotDirectory$}
		\State \Return ENOTDIR
	\EndIf
	\If {$canWrite(newParent, user, group)=false$ or $canEcecute(newParent, user, group)=false$}
		\State \Return EPERM
	\EndIf
	\State $oldName \gets path.getResName$
	\State $newName \gets newPath.getResName$
	\If {$newParent.hasNoOutVertex(newName)$}
		\State $resource.name \gets newName$
		\State $resource.removeInEdges$
		\State $newParent.addOutEdge(resource, newName)$
	\Else
		\State $otherRes \gets newParent.getOutEdge(newName)$
		\If {$otherRes.isNotDirectory$ and $resource.isDirectory$}
			\State \Return ENOTDIR
		\EndIf
		\If {$otherRes.isDirectory$ and $resource.isNotDirectory$}
			\State \Return EISDIR
		\EndIf
		\If {$otherRes.isDirectory$ and $otherRes.isEmpty$}
			\State \Return ENOTEMPTY
		\EndIf
		\State $resource.removeInEdges$
		\State $edgeSet \gets otherRes.getInEdges$
		\While {$edgeSet.isNotEmpty$} 
			\State $edge \gets edgeSet.extract$
			\State $edge.setVertices(newParent, resource)$
		\EndWhile
		\State $resource.name \gets newName$
		\State $otherRes.delete$
	\EndIf
	\State $parent.ctime \gets now$
	\State $parent.mtime \gets now$
	\State $resource.ctime \gets now$
	\State $newParent.ctime \gets now$
	\State $newParent.mtime \gets now$
	\State \Return 0
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage

\subsubsection{La gestione della policy delle risorse}
Come è stato analizzato nei paragrafi precedenti, la gestione della policy di una risorsa è determinata e dal proprietario (inteso sia come utente che come gruppo) e dai permessi che il proprietario ha stabilito per essa.

Questi tre elementi fanno parte di quella parte di dati che non concorrono a creare l'informazione vera su cui un utente lavora, ma fanno parte dei \emph{metadati} della risorsa, ossia quei dati \emph{sui dati} che permottono di identificarla univocamente e di gestirla in maniera opportuna. 

Tralasciando la presenza del superutente, che può tutto, in un sistema Unix la suddivisione utente/gruppo e permessi genera questo tipo di gestione: quando un utente desidera effettuare un'operazione viene verificato se i permessi da lui posseduti per quella risorsa sono sufficienti per portarla a termine; come si effettua il check? Semplicemente, in base al nome utente ed al gruppo vengono estratti dai permessi quei bit necessari alla verifica. Chi, però, stabilisce i permessi su un file, però, è solo ed esclusivamente l'utente proprietario della risorsa, che può cambiarli con il comando \emph{chmod} (che fa riferimento all'omonima system call) da terminale. Ecco perchè è importante questo dualismo proprietario-permessi: è il primo che concede o revoca i secondi, anche a se stesso se necessario. 

Il possesso di una risorsa può anche essere delegato ad un altro utente da terminale tramite il comando \emph{chown} (che richiama l'omonima system call).

Entrambi i metodi implementati fanno uso di un metodo privato, che si occupa di prendere la risorsa specificata nel path e restituirla nel caso in cui l'utente sia effettivamente il suo proprietario (e quindi abbia i diritti di eseguire una chmod o una chown) o l'utente \emph{root}, ne modificano il ctime ed aggiornano i dati con quelli richiesti.
\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione che verifica i diritti per eseguire chmod o chown}
\Function{getResourceForCh}{path, user, group, retValue}
	\State $resource \gets getResource(path, retValue, user, group)$
	\If {$resource=null$}
		\State \Return null
	\EndIf
	\If {$resource.isLink$}
		\State $resource \gets resource.followLinks$
		\If {$resource=null$}
			\State \Return null
		\EndIf
	\EndIf
	\If {$user.isRoot$}
		\State \Return resource
	\EndIf
	\If {$user=resource.user$ and $group=resource.group$}
		\State \Return resource
	\EndIf
	\State \Return null 
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione chown}
\Function{chown}{path, user, group, newUser, newGroup}
	\State $retValue \gets new IntWrapper()$
	\State $resource \gets getResourceForCh(path, retValue, user, group)$
	\If {$resource=null$}
		\State \Return retValue.value
	\EndIf
	\State $resource.ctime \gets now$
	\State $resource.user \gets newUser$	
	\State $resource.group \gets newGroup$
	\State \Return 0
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione chmod}
\Function{chmod}{path, user, group}
	\State $retValue \gets new IntWrapper()$
	\State $resource \gets getResourceForCh(path, retValue, user, group)$
	\If {$resource=null$}
		\State \Return retvalue.value
	\EndIf
	\State $resource.ctime \gets now$
	\State $resource.mode \gets mode$
	\State \Return 0
\EndFunction
\end{algorithmic}
\end{algorithm}
  
\newpage
  
\subsubsection{Le funzione write e read}
Sebbene le funzioni che sono state fin'ora analizzate siano tutte importanti, in un filesystem sono presenti altre due funzioni che sono indispensabili (oltre alle già discusse funzioni di creazione di risorse): la \emph{write} e la \emph{read}.

Basandosi sulla rappresentazione delle risorse già introdotta, abbiamo che un file può (e deve) avere un'informazione da mettere a disposizione dell'utente per l'utente. In un comune filesystem i dati vengono divisi in blocchi di dimensione fissa e sono accedibili tramite gli inode; si ha così un'allocazione dinamica della memoria che segue le necessità dell'utente (una dimensione del file maggiore comporta un maggior numero blocchi allocati), che limita gli sprechi di spazio e che permette di riallocare i blocchi disallocati.

Una simile implementazione appare evidente essere impossibile da realizzare in un dispositivo che di sua natura non è a blocchi, seppur appaia come la scelta più saggia da intraprendere. La simulazione di un tale comportamento è però offerta dal database su cui si basa questa implementazione: OrientDB, a differenza di un database relazionale, in cui la \emph{prima forma normale} richiede che i valori associati ad una tupla siano tutti di tipo elementare, permette di memorizzare degli oggetti, ed in questo caso l'oggetto necessario è una lista, in particolare è stato utilizzato un \emph{ArrayList}.

Questo oggetto, va sottolineato, viene utilizzato in coppia con un'altra caratteristica propria di OrientDB, la capacità di memorizzare informazioni binarie; fin'ora abbiamo visto che tutto ciò che è stato memorizzato nel database è stato salvato sotto forma di  ODocument\footnote{OVertex, OEdge e qualsiasi altra risorsa fin'ora usata altro non era che un'estensione della classe ODocument, ma concretamente si è operato con dei documenti}, ma si ha a disposizione anche un'altra risorsa concreta, l'OrecordBytes, che come riportato nella documentazione ufficiale, è un tipo di record capace di memorizzare dati binari senza necessità di effettuare alcuna conversione. Questo tipo di record può prendere o cedere informazioni in stream o direttamente in un array di byte (il vantaggio di usare questa loro implementazione piuttosto che un array di byte Java verrà discusso nel capitolo seguente).

OrientDB permette di salvare record binari senza necessità di stabilirne una dimensione fissa, possiamo quindi avere record che memorizzano 27byte ed altri record che ne memorizzano un milione, e in questa imnplementazione essa viene imposta per motivi di praticità settando la variabile CHUNK\_SIZE. Inoltre un vantaggio significativo dell'uso dei record binary è quello di non avere necessità di caricare in memoria tutto il file richiesto in una volta, ma caricare solo i \emph{riferimenti} ai record. Abbiamo quindi una struttura in cui, da una parte, abbiamo l'ArrayList che tiene dinamicamente i puntatori ai record, e dall'altra parte i record.

Si supponga che venga richiesta la lettura di un file la cui dimensione è di 500MB, e di creare un filesystem i cui blocchi hanno una dimensione di 256kB, questo comporta l'allocazione di 2000 blocchi; nel momento in cui al record vengono richiesti i dati non si renderà necessario caricare in memoria l'intero file, con il rischio di terminare spazione nello heap, ma sarà possibile caricare blocco per blocco, con un'occupazione in memoria costante di soli 256kB, permettendo così anche un accesso di tipo ibrido tra il sequenziale (in cui la lettura inizia per forza dalla posizione 0) ed il random (in cui è possibile effettuare una lettura in qualsiasi punto arbitrario). Se poi, durante un'operazione di scrittura si renderà necessario allocare nuovi blocchi, o, al contrario, rimuoverli, sarà possibile farlo in maniera efficiente.

Il metodo che permette la scrittura di un file richiede che vengano specificati il path della risorsa da scrivere, un array di byte rappresentanti i dati, un offset da cui iniziare la scrittura, un numero che indica quanti byte scrivere, oltre che le credenziali dell'utente.

Inizialmente viene verificato se la risorsa specificata nel path esiste, se non dovesse esistere e fosse possibile crearla, viene richiesto al metodo che si occupa della creazione di risorse, di inizializzare un nuovo file. Successivamente, se la risorsa specificata è un Link, allora si segue fino ad arrivare alla risorsa linkata, se invece viene richiesta la scrittura su una directory viene ritornato un errore; controllati i permessi in scrittura sul file, si passa ad allocare eventuali nuovi blocchi necessari, per poi effettuare la scrittura vera e propria, che termina con un aggiornamento dei tempi di modifica e cambiamento, oltre che della dimensione del file e dei puntatori di record.

Analizzata la funzione \emph{write}, non resta molto da aggiungere per poter introdurre la \emph{read}, se non che questa richiede un offset da cui iniziare la lettura ed il numero di quanti byte (al più) sono richiesti.

\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione write}
\Function{write}{path, data, offset, size, user, group}
	\State $retValue \gets new IntWrapper()$
	\State $resource \gets getResource(path, retValue, user, group)$
	\If {$resource=null$ and $offset=0$}
		\State $err \gets create_resource(path, 0755, user, group, "File", noCommit)$
		\If {$err=0$}
			\State \Return write(path, data, offset, size, user, group)
		\Else
			\State \Return err
		\EndIf
	\EndIf
	\If {$resource=null$}
		\State \Return ENOENT
	\EndIf
	\If {$resource.isLink$}
		\State $resource \gets resource.folowLinks$
	\EndIf
	\If {$resource.isLink$}
		\State \Return ENOENT
	\ElsIf {$resource.isDirectory$}
		\State \Return EISDIR
	\EndIf
	\If {$canWrite(resource, user, group)=false$}
		\State \Return EPERM
	\EndIf
	\State $fileSize \gets resource.size$
	\If {$fileSize < offset - 1$}
		\State \Return EOF
	\EndIf
	\State $resource.allocRequiredBlocks$
	\State $remaining \gets size$
	\State $index \gets offset / CHUNK_SIZE$
	\State $dataIndex \gets 0$
	\While {$remaining > 0$}
		\State $buffer \gets resource.loadBlock(index)$
		\If {$remaining=size$ and $offset \% CHUNK\_SIZE > 0$}
			\State $offPos \gets offset \% CHUNK\_SIZE$
			\State $copiedBytes \gets min(size, CHUNK\_SIZE - offPos)$
			\State $arraycopy(data, 0, buffer, offPos, copiedBytes)$
		\Else
			\State $copiedBytes \gets min(remaining, CHUNK\_SIZE)$
			\State $arraycopy(data, dataIndex, buffer, 0, copiedBytes)$
		\EndIf
		\State $buffer.saveBlock$
		\State $remaining \gets remaining-copiedbytes$
		\State $dataIndex \gets dataIndex + copiedBytes$
		\State $index++$
	\EndWhile
	\State $resource.size \gets max(offset+size, fileSize)$
	\State $resource.ctime \gets now$
	\State $resource.mtime \gets now$
	\State \Return size
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione read}
\Function{read}{path, offset, size, user, group, retVal}
	\State $resource \gets getResource(path, retValue, user, group)$
	\If {$resource=null$}
		\State \Return null
	\EndIf
	\If {$resource.isLink$}
		\State $resource \gets resource.folowLinks$
	\EndIf
	\If {$resource.isLink$}
		\State $retValue.value \gets ENOENT$
		\State \Return null
	\ElsIf {$resource.isDirectory$}
		\State $retValue.value \gets EISDIR$
		\State \Return null
	\EndIf
	\If {$canRead(resource, user, group)=false$}
		\State $retValue.value \gets EPERM$ 
		\State \Return null
	\EndIf
	\State $fileSize \gets resource.size$
	\If {$fileSize < offset - 1$}
		\State $retValue.value \gets EOF$ 
		\State \Return null
	\EndIf
	\If {$offset+size > fileSize$}
		\State $size \gets fileSize - offset$
	\EndIf
	\State $data \gets byte[size]$
	\State $startRecord \gets offset/CHUNK\_SIZE$
	\State $endRecord \gets (offset+size)/CHUNK\_SIZE$
	\If {$(offset+size) \% CHUNK\_SIZE = 0$}
		\State $endRecord--$
	\EndIf
	\State $index \gets startRecord$
	\State $dataIndex \gets 0$
	\While {$dataindex < size$}
		\State $buffer \gets resource.loadBlock(index)$
		\If {$index=startRecord$}
			\State $copiedBytes \gets min(size-dataIndex, CHUNK\_SIZE - offset\%CHUNK\_SIZE)$
			\State $data.append(buffer, offset\%CHUNK\_SIZE, copiedBytes)$
		\ElsIf {$index=endRecord$}
			\State $copiedBytes \gets size-dataIndex$		
			\State $data.append(buffer, 0, copiedBytes)$	
		\Else
			\State $copiedBytes \gets CHUNK\_SIZE$
			\State $data.append(buffer, 0, CHUNK_SIZE)$
		\EndIf
			\State $dataIndex \gets dataIndex+copiedBytes$
			\State $index++$
	\EndWhile
	\State $resource.atime \gets now$
	\State \Return data
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage

\subsubsection{La funzione truncate}
Insieme alla \emph{read} ed alla \emph{write} è presente una terza funzione di gestione dei file, la \emph{truncate}; come riportanto alla pagina internet \emph{http://unixhelp.ed.ac.uk/CGI/man-cgi?truncate+2}, questo metodo comporta il ridimensionamento del file su cui è invocato, e prevede la specifica di una dimensione. Se questa dimensione è minore dell'attuale dimensione del file, allora l'informazione eccedente è persa, mentre se è maggiore, il file viene esteso, e la parte nuova viene colmata con dei byte 0.

Poichè ridimensionare un file comporta la necessità di allocare o disallocare blocchi di memoria, anche questa funzione opera con gli ORecordBytes e la lista di puntatori ad essi.

Proprio in questa situazione si può apprezzare una delle differenze tra un dispositivo a blocchi virtuali ed uno a blocchi fisici: mentre l'operazione di disallocamento comporta classicamente la cancellazione degli inode ineteressati, con conseguente frammentazione del disco, in OrientDB questo non accade, poichè non sono solo i puntatori degli ORecordBytes ad essere eliminati, ma i record stessi. Questa strategia, pur se non ottimale (dal momento che la creazione di un record non è un'operazione \emph{costless}), è stata obbligata per permettere di sfruttare tutto lo spazio necessario e non di più: mantenere infatti dei record nel database per permettere il loro \emph{riciclo} avrebbe comportato la necessità di occupare spazio su disco inutilmente, con conseguente rischio di saturarlo.

Poichè il comportamento standard richiede che, nel caso di un'estensione del file, i nuovi byte siano posti a 0, si è reso necessario compiere una scelta: o i byte eccedenti del blocco vengono messi a 0 (ovvero viene eseguita una sovrascrittura di tutti 0) quando il file è ridimensionato in positivo, o quando viene ridimensionato in negativo. La scelta è completamente arbitraria, e nessuna soluzione comporta perdite prestazionali rispetto all'altra. In questa implementazione è stato preferito eseguire l'annullamento in fase di resize negativo. Per il resto il comportamento è analogo a quello tenuto dalla \emph{write}, verrà presentato lo pseudocodice senza dare ulteriori spiegazioni.

\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione truncate}
\Function{truncate}{path, size, user, group}
	\State $resource \gets getResource(path, retValue, user, group)$
	\If {$resource=null$}
		\State \Return ENOENT
	\EndIf
	\If {$resource.isLink$}
		\State $resource \gets resource.folowLinks$
	\EndIf
	\If {$resource.isLink$}
		\State \Return ENOENT
	\ElsIf {$resource.isDirectory$}
		\State \Return EISDIR
	\EndIf
	\If {$canWrite(resource, user, group)=false$}
		\State \Return EPERMS
	\EndIf
	\If {$size=0$}
		\State resource.deallocAll
		\State \Return 0
	\EndIf	
	\State $fileSize \gets resource.size$
	\If {$fileSize=size$}
		\State \Return 0
	\EndIf
	\State $resource.allocRequiredBlocks$	
	\If {$fileSize > size$}
		\State $resource.zeroExceedBytes$
	\EndIf
	\State $resource.size \gets size$
	\State $resource.mtime \gets now$
	\State $resource.ctime \gets now$
	\State \Return 0
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage

\subsubsection{La funzione readdir}
Una caratteristica dei filesystem che li rende navigabili è la possibilità di visualizzare la struttura in cui ci troviamo, ossia le risorse che da una determinata directory sono accessibili. La funzione che rende possibile tutto ciò è è un'analoga logica della \emph{read}, la \emph{readdir}; come espresso anche dal nome, questa esegue una lettura del contenuto di una directory, e nell'implementazione dei classici filesystem essa restituisce un puntatore ad una sequenza di strutture contenenti le informazioni richieste. Poichè in Java il concetto di \emph{struct} non è presente, l'attuale implementazione restituisce una lista di oggetti, istanze della classe DirList che ha due attributi privati, reName e resType, accessibili tramite i corrispondenti \emph{getter}. 

Questo metodo richiede in input il path della risorsa di cui leggere il contenuto, oltre alle credenziali dell'utente e una varibile dove inserire un eventuale codice di errore. Se la risorsa richiesta non esiste, è un file, o è un link la cui risorsa linkata è stata eliminata allora l'esecuzione termina riportando il codice appropiato. Successivamente viene preso l'insieme di vertici uscenti dalla directory richiesta e, elemento per elemento, vengono aggiunte le informazioni alla lista che poi sarà restituita.

\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione readdir}
\Function{readdir}{path, user, group, retValue}
	\State $retValue \gets new IntWrapper()$
	\State $resource \gets getResource(path, retValue, user, group)$
	\If {$resource=null$}
		\State $retValue.value \gets ENOENT$
		\State \Return null
	\EndIf
	\If {$resource.isLink$}
		\State $resource \gets resource.folowLinks$
	\EndIf
	\If {$resource.isLink$}
		\State $retValue.value \gets ENOENT$
		\State \Return null
	\ElsIf {$resource.isFile$}
		\State $retValue.value \gets ENOTDIR$
		\State \Return null
	\EndIf
	\If {$canRead(resource, user, group)=false$}
		\State $retValue.value \gets EPERM$
		\State \Return null
	\EndIf
	\State $vertices \gets resource.getOutVertices$
	\While {$vertices.isNotEmpty$}
		\State $vertex \gets vertices.extract$
		\State $list.add(new DirList(vertex.name, vertex.type))$
	\EndWhile
	\State $resource.atime \gets now$
	\State \Return list
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage

\subsubsection {La funzione utime}
Un'ultima funzionalità messa a disposizione dai filesystem è quella di poter modificare di tempi di accesso e/o di modifica di una risorsa

La policy attuata per poter usare questo metodo nei filesystem comuni, e riproposta in questa implementazione, è la seguente:
\begin{itemize}
\item se chi invoca il metodo è il proprietario della risorsa o è l'utente amministratore, allora atime e mtime sono modificati coerentemente con i dati passati, e sostituiti con il timestamp attuale se nulli;
\item se chi invoca il metodo non è il proprietario della risorsa, ma ha comunque permessi di scrittura su essa allora i valori atime e ctime sono settati con il timestamp attuale;
\item ogni altro tentativo viene bloccato.
\end{itemize}
\begin{algorithm}
\begin{algorithmic}[5]
\caption{La funzione utime}
\Function{utime}{path, user, group, retValue}
	\State $retValue \gets new IntWrapper()$
	\State $resource \gets getResource(path, retValue, user, group)$
	\If {$resource=null$}
		\State $retValue.value \gets ENOENT$
		\State \Return null
	\EndIf
	\If {$resource.isLink$}
		\State $resource \gets resource.folowLinks$
	\EndIf
	\If {$resource.isLink$}
		\State $retValue.value \gets ENOENT$
		\State \Return null
	\EndIf
	\If {$user.isRoot$ or $user.isOwner$}
		\If {$atime=null$}
			\State $atime \gets now$
		\EndIf
		\If {$mtime=null$}
			\State $mtime \gets now$
		\EndIf
	\ElsIf {$atime=null$ and $ctime=null$ and $canWrite(resource, user, group)$}
		\State $atime \gets now$
		\State $mtime \gets now$
	\Else
		\State \Return EPERM
	\EndIf
	\State $resource.atime \gets atime$
	\State $resource.mtime \gets mtime$
	\State \Return 0
\EndFunction
\end{algorithmic}
\end{algorithm}