\chapter{L'implementazione del filesystem virtuale}

\section{Una vista d'insieme}
\subsection{La struttura del progetto}
Il lavoro che verrà presentato di seguito costituisce non l'intera implementazione del progetto, ma una parte di essa. Per ragioni di complessità, infatti, è stato deciso di dividere il lavoro in due parti distinte e relativamente indipendenti.
Realizzare un driver fuse comporterebbe effettivamente la scrittura del driver vero e proprio, l'implementazione della parte relativa al data storage e la progettazione della comunicazione tra i due strati software.

Come è noto, fuse è una libreria \emph{poliglotta}, nel senso che esistono vari linguaggi che permettono di implementare un driver di questo tipo (C, C++, Java, Python sono tra i più noti), ma, storicamente, quello più usato, e quindi testato, è stato il C; gli altri linguaggi, oltre a non avere una documentazione comparabile a quella disponibile per C, non sono ufficiali, nel senso che sono implementazioni \emph{custom}, con i difetti e le instabilità che questo comporta.

In base a quanto sopra, la scelta del linguaggio con cui realizzare il driver fuse è stata il C. Dall'altra parte, però, si sono presentati problemi opposti: OrientDB è un database \emph{pure Java} e mette a disposizione API native per questo linguaggio. Anche in questo caso, la comunità ha sviluppato dei driver che permettono l'uso di OrientDB anche in altri linguaggi, quali C\#, C++, C, PHP.ettivamente
Il problema che si è presentato è stato sempre lo stesso: questi driver non permettono di sfruttare in pieno le potenzialità di orientDB, ed inoltre sono troppo recenti per essere considerati una buona base su cui costruire un lavoro importante come questo.

La scelta finale, per entrambi gli \emph{end-point} del lavoro, è stata quella di prediligere i linguaggi nativi. Questo ha comportato la necessità di realizzare un'infrastruttura di comunicazione tra i due linguaggi, e le possibilità analizzate sono state:

\begin{itemize}
\item \emph{JNI} La prima idea è stata quella di usare JNI, acronimo di Java Native Interface. Come viene definita nella documentazione Oracle, e rimarcato anche in quella IBM, la JNI è un'interfaccia di programmazione utilizzata per scrivere metodi nativi ed integrare la Java virtual machine in applicazioni C/C++. Di conseguenza, quello che JNI rende possibile, spiegando è possibile invocare funzioni scritte in C e C++ da Java, e viceversa.
La maggiore difficoltà che avrebbe comportato questa scelta sarebbe stata la compatibilità cone le varie JVM. L'interfaccia JNI, infatti, andando a lavorare a basso livello, non è uno standard, ma è legata alla singola implementazione, e l'uso di diverse JVM avrebbe comportato la potenziale non compatibilità, rendendo vano l'impegno.
Oltre a ciò, la documentazione ufficiale è aggiornata alla versione 1.2 di Java.
\item \emph{Socket} In un secondo momento è stato ipotizzato l'uso delle socket e del framework \emph{zeromq}, così da semplificare lo svilupppo; il motivo per cui questa idea è stata abbandonata consiste nelle difficoltà intrinseche dell'uso delle socket per applicazioni così varie: si sarebbe reso necessario creare un protocollo di comunicazione client-server, e fare ciò in maniera efficiente avrebbbe richiesto un imponente sforzo, oltre che la fase di debug dell'applicazione si sarebbe complicata e non sarebbe stato possibile ampliare il lavoro in futuro senza grossi sforzi.
\item \emph{Web service Rest} Infine si è arrivati alla scelta di creare un web service Rest per la comunicazione client-server. Ciò permette di non costringere i futuri manutentori del software a modifiche sostanziali, ma a limitarsi allo strato necessario. Infatti utilizzando questa tecnologia è possibile riconoscere nell'architettura complessiva del progetto tre \emph{layer} distinti: il client-driver, lo strato comunicazione e lo strato storage. Inoltre è possibile, con un minimo sforzo, ampliare i servizi offerti da fuse\footnote{Si pensi, ad esempio, alla semplicità con cui sarebbe possibile creare un'interfaccia web per la gestione del filesystem in un ambiente su cui non sia disponibile fuse.}.
\end{itemize}
Quello che viene trattato in questo lavoro è la parte relativa al data storage, ovvero al terzo ed ultimo strato software.
Nei paragrafi che seguono verranno analizati nel dettaglio i componenti ed il funzionamento di questo layer, a partire dal linguaggio utilizzato per interrogare il database.
\subsection{Le API Blueprints}
L'autore del testo ha deciso di iniziare l'analisi del data-storage dalla tecnologia utilizzata concretamente per interfacciarsi con il database. Come abbiamo visto nel capitolo precedente, OrientDB può essere utilizzato in due modalità: a grafo o documentale; la struttura che più si presta all'implementazione di un filesystem virtuale, naturalmente, è la prima.

Una differenza sostanziale tra un database relazionale ed un database non relazionale consiste nel modo in cui questo può essere interrogato: nel primo caso abbiamo a disposizione l'SQL, ovvero un linguaggio dichiarativo multidatabase, utilizzabile sia da riga di comando, sia da applicazione (tramite l'uso di specifici driver). Nel secondo caso, invece, non è possibile trovare un linguaggio multidatabase standardizzato, ma ciascun produttore offre delle proprie API, e queste sono strettamente legate al prodotto in questione. Nel caso di OrientDB, come abbiamo accennato, le API sono disponibili in Java; sono inoltre disponibili porting non ufficiali anche per altri linguaggi. 

Lavorare a livello database è però inefficiente dal punto di vista del \emph{throuhput}, in quanto è necessario gestire molti fattori, come la cache, l'uso di transazioni o le indicizzazioni.

Quali sono allora i vantaggi di usare OrientDB? Il vantaggio consiste dal poter usufruire della combinazione di OrientDB e dello stack Tinkerpop. Quest'ultimo, come viene definito dal sito del produttore, è uno stack open-source, Java oriented, per il panorama emergente dei grafi; esso fornisce le basi per costruire applicazioni ad alte performance di qualsiasi dimensione che operino su grafi, e sono in grado di scalare da una semplice modellazione dei dati, fino a gestire grafi da un trilione di nodi distribuiti su un cluster di computer. In particolare Tinkerpop è costituito da:
\begin{itemize}
\item \emph{Blueprints} offre un'interfaccia verso il modello a grafi per i database con delle implementazioni già realizzate.
\item \emph{Pipes} è un framework che permette il controllo del flusso dei dati, dall'input all'output.
\item \emph{Gremlin} è un linguaggio specifico per effettuare il \emph{traversing} dei grafi.
\item \emph {Frames} permette di lavorare con gli oggetti Blueprints come fossero degli ogggetti Java, nascondendo il fatto che in realtà si sta operando con nodi e vertici.
\item \emph{Furnace} fornisce degli algoritmi specifici per lavorare con i grafi.
\item \emph{Rexster} è un server multi protocollo, con particolare attenzione a Rest, che espone i database che implementano Blueprints.
\end{itemize}
La scelta di Blueprints, e, quindi, di Tinkerpop, è stata effettuata principalmente basandosi sul criterio fondamentale della \emph{modularità} dell'applicazione. L'implementazione dell'interfaccia Blueprints da parte di OrientDB rimane totalmente isolata al programmatore, che potrà quindi concentrarsi più sul proprio codice e sfruttare al meglio le potenzialità offerte dallo storage sottostante, con la sicurezza che eventuali bug o problemi di performance verranno risolti in maniera trasparente.

Un esempio che aiuterà a comprendere come l'uso di Blueprints aiuti il programmatore a pensare al cosa piuttosto che al come deriva dalla nuova\footnote{Ci si riferisce alla release del 7/6/2013} implementazione fornita da OrientDB; quando si desidera creare un nuovo \emph{edge} tra due vertici senza che però esso stesso debba memorizzare informazioni, utilizzando le \emph{raw} API si hanno due possibilità: creare un vero edge, comportando la creazione di un ODocument\footnote{L'elemento utilizzato da orientDB per memorizzare i dati} vuoto, che comunque occupa spazio in memoria e richiede, nella fase di traversing, di caricare il record in questione, o memorizzare come campo del vertice \emph{parent} un collegamento diretto ad esso. Naturalmente la prima soluzione appare più semplice da realizzare e manutenere nel tempo, seppur si riveli la più inefficiente a causa dell'inutile caricamento da disco di un record non necessario, mentre la seconda, seppur ottimale, risulta essere la più complessa da implementare, per via della macchinosità della soluzione trovata. OrientDB nell'implementazione dell'interfaccia Blueprints risolve il problema introducendo il concetto di \emph{lightweight edge}, ovvero archi leggeri, senza campi di informazioni proprie; se la creazione richiesta è per un lightway edge allora automaticamente viene usata la seconda strategia, mentre se l'arco ha informazioni viene creato un documento. Tutto ciò viene fatto in automatico dal sistema, senza richiedere l'intervento del programmatore, che così si concentra sul cosa (creazione dell'arco), e non sul come (adottare la prima o la seconda strategia).

Oltre a ciò non va trascurato il fatto che Blueprints, così come tutto lo stack Tinkerpop, è multipiattaforma: lo stesso codice utilizzato per costruire e modellare il virtual filesystem su base OrientDB, con piccole modifiche, può essere utilizzato su altri database che implementano questa interfaccia (come ad esempio Neo4j o MongoDB\footnote{Anche se MongoDB non è un database a grafi gli sviluppatori hanno comunque dato un'implementazione dell'interfaccia Blueprints tale da simularne un comportamento}).

La flessibilità della scelta si dimostra anche nel momento in cui si dovesse rendere necessario scendere ad un maggior livello di dettaglio nell'uso del database: Blueprints offre la possibilità di ottenere il database a basso livello, come nel caso si necessiti di \emph{tuning} del sistema (gestione della cache, accesso ad eventuali indici) o, più semplicemente, nel caso in cui si debbano usare delle funzionalità che Blueprints non offre\footnote{Ad esempio Blueprints non prevede la presenza di una root. Questo comportamento deriva dal fatto che esistono due distinte correnti riguardo la gestione dei database a grafo: i produttori che considerano la root un elemento essenziale del grafo, e quelli che eliminano questo concetto. Essendo Blueprints un framework trasversale, necessita di essere quanto più possibile generico, e quindi non può offrire funzionalità che poi non tutti i produttori sono in grado di offrire. Attualmente OrientDB utilizza un approccio libero, ovvero se si vuole è possibile creare una o più root ed assegnare loro un nome, così da facilitarne il recupero.}.

\section{Il filesystem virtuale}
In questa sezione sarà analizzata l'implementazione del filesystem virtuale, analizzando le scelte e le strategie adottate, mentre i test saranno discussi nel capitolo che segue.
Tutto il codice qui discusso è disponibile alla pagina internet \emph{http://github.com/litiales/fuse-driver-for-orientDB/tree/master/OVirtualFileSystem}
Gli argomento trattati saranno discussi seguento questo ordine:
\begin{itemize}
\item \emph{Creazione ed apertura del filesystem}
\item \emph{La rappresentazione dei dati}
\item \emph{Gestione dei permessi}
\item \emph{Data browsing}
\item \emph{Funzioni sul filesystem}
\end{itemize}

\subsection{Creazione ed apertura del filesystem}
Fondamentale per poter operare con ogni filesystem è poterne eseguire un \emph{mount}, operazione che, come si può apprendere eseguendo il comando \emph{man mount}, consiste nel rendere disponibile in una directory specificata dall'utente i file contenuti in esso. 
Questo significa che, al momento in cui un utente richiederà di accedere al suo filesystem il sistema deve essere in grado di convertire i file di storage che abbiamo visto al Capitolo 2 in un qualcosa che abbia senso e che sia concretamente disponibile.

Per soddisfare questa richiesta, è presente la classe \emph{OVFSManager}: la sua implementazione è piuttosto semplice, in quanto è costituita da funzioni di gestione primitiva del database, quali l'apertura e/o la creazione, la chiusura e l'eliminazione. Accanto ad esse troviamo degli atributi che contengono tutto il necessario per operare poi concretamente con il filesystem.

Il costruttore della classe è un accessibile solo attraverso metodi statici in quanto orientDB prevede la possibilità di specificare un path specifico per il salvataggio del database, oltre che la possibilità di specificare un utente ed una password specifici, ed a seconda delle necessità dell'utente verrà richiamata la funzione adatta. In effetti tutte e quattro le funzioni fanno poi una chiamata allo stesso costruttore, passando parametri standard o personalizzati, restituendo una istanza della classe. Va sottolineato come il sistema sottostante debba mantenere in memoria una sola istanza della classe per ciascun database aperto, in quanto l'uso embedded di orientDB non prevede la sincronizzazione tra processi concorrenti, la richiesta di riapertura di uno stesso filesystem comporterebbe degli errori di consistenza. Questo è il caso in cui due o più utenti richiedano il mount per uno stesso filesystem: il sistema dovrà occuparsi di gestire le richieste accedende sempre e solo alla stessa istanza di OVFSManager, mentre se la richiesta è per filesystem diversi non ci sono problemi, sarà possibile gestire più istanze simultaneamente.

Un'ulteriore caratteristica di questa classe è la capacità di gestire una prima apertura del database come se già esistesse, ovvero il sistema non ha il compito di controllare l'esistenza di uno specifico filesystem: se il filesystem esiste verrà aperto, altrimenti verrà creato usando i parametri specificati e poi aperto.

\subsection {La rappresentazione dei dati}
Sicuramente la parte più significativa da un punto di vista implementativo è il modello della rappresentazione dei dati: scegliere una rappresentazione corretta significa semplicità nella scrittura delle funzioni e minor tasso di errori, scegliere una rappresentazione complessa significa rendere complessa, se non impossibile, l'aggiunta di funzionalità.
Per definire il modello dei dati adottato in questa implementazione è stata seguita la rappresentazione ad alto livello di un qualunque filesystem. Questo significa che, mentre normalmente vengono usati gli \emph{inode} a cui sono collegati i dati veri e propri, questo filesystem lavora \emph{nativamente} con una struttura a grafo.

Capire il perchè e quali vantaggi/svantaggi questo modelli comporti si pensi che quando si richiede una risorsa ad un filesystem si chiede in realtà all'inode corrispondente di caricare i dati effettivi: abbiamo così un doppio livello di memorizzazione, il livello degli inode ed il livello fisico dei bit memorizzati, proprio come in una qualsiasi implementazione di filesystem in un database relazionale in cui non è possibile avere dati strutturati. Il problema in orientDB non sussiste, essendo possibile definire un grafo. Effettivamente questa scelta potrebbe comportare problemi di performance, in quanto per poter attraversare un nodo sarebbe necessario caricare l'intero record, magari contenente centinaia di byte; l'implementazione di orientDB, invece, non comporta questo genere di problemi, in quanto implementa un meccanismo di lazy loading, ovvero un record viene effettivamente caricato solo quando necessario, e non al suo accesso. Abbiamo quindi un meccanismo analogo a quello degli inode e dei blocchi di dati, senza però che si implementino effettivamente due strutture separate.

 La rappresentazione scelta è stata dunque quella di far equivalere una qualsiasi risorsa, sia essa un link, una directory od un file, ad un vertice del grafo. Per permettere poi la consistenza dei dati, viene creata, al momento dell'inizializzazione del database, un nodo \emph{root} che non può essere eliminato, e che consente l'accesso al filesystem da un unico punto, semplificando la navigazione. Oltre ciò, sfruttando la possibilità di dare a ciascun nodo una label, è possibile conoscere in tempo O(1) il tipo di risorsa che si sta trattando, sia essa una Directory, un File od un Link.
 
 Definite le risorse, è possibile stabilire una gerarchia su di esse, ovvero dei collegamenti che definiscono come il filesystem è articolato. Per ottenere ciò è stato utilizzata la creazione di archi leggeri, che non occupano spazio in memoria, e che richiedono un tempo di attraversamento costante. La strategia adottata è la seguente: si supponga di avere una directory \emph{Dir}, e di voler creare in essa il file \emph{file}; una volta creati i due nodi si crea un arco leggero uscente da \emph{Dir} ed entrante in \emph{file}, con label il nome del file. Analogamente si supponga di avere una risorsa \emph{Resource} e di volerla linkare al link \emph{link}; una volta create le due risorse è sufficiente creare un arco uscente da \emph{linkedRes} ed entrante in \emph{resource} con label \emph{link}. Con questa rappresentazione, dato un path, sarà possibile navigare il filesystem in tempo costante dal momento che non è possibile avere due risorse in una stessa directory con lo stesso nome e quindi l'attraversamento di ciascun arco avrà costo O(1).
 
 \subsection{La gestione dei permessi}
 Tutti i filesystem più recenti dispongono della possibilità di gestire i permessi di una risorsa, ovvero cosa un utente può o non può fare. Nell'implementazione classica di Unix a ciascun file o cartella è associato un permesso, costituito da un numero ottale a tre cifre: da sinistra verso destra le cifre codificano rispettivamente i permessi sulla risorsa assegnati all'utente proprietario, agli utenti appartenenti allo stesso gruppo del proprietario ed a tutti gli altri utenti. Essendo la rappresentazione numerica di tipo ottale, ciascuna cifra viene a sua volta codificata da tre bit, che, da sinistra verso destra, se impostati ad uno, esprimono la possibilità di scrittura, lettura o esecuzione.
 
 Una tale gestione delle risorse è stata ritenuta fondamentale per permettere la scalabilità del filesystem: nel momento in cui si debba condividere le risorse tra più utenti, si rende necessario stabilire una policy su cosa e come si possa fare. Supponiamo che Alice voglia condividere con gli utenti un file importante, ma che voglia esser certa che tale file non venga modificato; se non fosse possibile stabilire delle limitazioni, Bob potrebbe prendere il file ed aggiungere o eliminare dati importanti. Così facendo, invece, basta che Alice imposti come permessi su file, ad esempio, 0744, così chiunque può leggere il contenuto del file, ma nessuno, se non Alice stessa, può modificarlo.
 
 Purtroppo però la gestione dei permessi in un filesystem non condiviso è lasciata al fatto che, almeno teoricamente, i permessi da superutente possa averli solo l'amministratore del sistema, che può fare tutto con i file, senza limitazione alcuna. Questo meccanismo viene meno nel caso in cui si decida di condividere lo stesso filesystem tra più utenti senza che esista una password da amministratore: potenzialmente si lascia a chiunque la possibilità di agire da superutente, proprio come se tutti fossero presenti nel file \emph{sudoers}\footnote{Il file in Unix contiene la lista degli utenti che possono usare la loro password per accedere temporaneamente come amministratori attraverso il comando \emph{sudo}}. Questa scelta implementativa è stata fatta in quanto si suppone che gli utenti che accedono al filesystem siano utenti fidati, e che non abbino quindi intenzioni malevole\footnote{Come viene riportato al primo comando sudo in ArchLinux \emph{"Da grandi poteri derivano granbdi responsabilità}}.
 
 Nell'implementazione del filesystem virtuale i permessi sono rappresentati come una stringa di quattro caratteri che codifica il numero ottale (il primo carattere è uno 0), ed è salvata nel campo \emph{mode} dei nodi (nel caso dei Link, così come in Unix, i permessi su di essi sono gli stessi di quelli delle risorse linkate). La gestione dei permessi è effettuata dalla classe ModeManager, una classe con un unico costruttore privato (così da rendere impossibile crearne un'istanza) in cui tutti i metodi sono statici; così facendo si garantisce che la stessa classe viene condivisa tra più istanze di filesystem, risparmiando spazio in memoria.
 
 Sarà ora presentato lo pseudocodice delle funzioni, ma essendo il codice autoesplicativo ci si limiterà a questo.   
\begin{algorithm}
\caption{Ritorna la cifra corretta su cui controllare i permessi in base al proprio nome utente e gruppo}
\begin{algorithmic}
\Function{getPermission}{resource, user, group}
\State $uOwn\gets resource.get(owner)$
\State $uGroup\gets resource.get(group)$
\State $mode\gets resource.get(mode)$
\If {$uOwn=user$ and $uGroup=group$}
	\State \Return $mode.substr(1,2)$
\ElsIf {$uOwn<>user$ and $uGroup=group$}
	\State \Return $mode.substr(2,3)$
\Else
	\State \Return $mode.substr(3,4)$
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{Ritorna true se si hanno i permessi per scrivere}
\begin{algorithmic}
\Function{canWrite}{resource, user, group}
\If {$user=root$ and $group=root$}
	\State \Return true
\EndIf
\State $perm \gets getPermission(resource, user, group)$
\If {$perm=2$ or $perm=3$ or $perm=6$ or $perm=7$}
	\State \Return true
\EndIf
\State \Return false
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{Ritorna true se si hanno i permessi per leggere}
\begin{algorithmic}
\Function{canRead}{resource, user, group}
\If {$user=root$ and $group=root$}
	\State \Return true
\EndIf
\State $perm \gets getPermission(resource, user, group)$
\If {$perm > 3$}
	\State \Return true
\EndIf
\State \Return false
\EndFunction
\end{algorithmic}
\end{algorithm}
   \begin{algorithm}
\caption{Ritorna true se si hanno i permessi per l'esecuzione}
\begin{algorithmic}
\Function{canExecute}{resource, user, group}
\If {$user=root$ and $group=root$}
	\State \Return true
\EndIf
\State $perm \gets getPermission(resource, user, group)$
\If {$perm \% 2 = 1$}
	\State \Return true
\EndIf
\State \Return false
\EndFunction
\end{algorithmic}
\end{algorithm}
\subsection{Data browsing}
Come già sottolineato, montare un filesystem significa costruire un albero, ovvero stabilire una gerarchia tra risorse, ed operare su un filesystem si riduce a due operazione fondamentali: navigare il filesystem fino alla risorsa desiderata per poi operare effettivamente.

Risulta quindi necessario avere un meccanismo sicuro ed efficiente che permette di effettuare il \emph{browsing} del tree, altrimenti qualsiasi implementazione ottima al momento dell'operazione viene vanificata. La struttura che è stata data filesystem è già stata analizzata due paragrafi fa e non verrà ritrattata in questo luogo. Quello che sarà invece approfondito è il come questa struttura viene sfruttata dalla classe ODatabaseBrowser. 

Questa classe ha un attributo in cui è memorizzata la root del filesystem, e tre metodi, di cui uno privato e due visibili solo all'interno del package, oltre ad un quarto metodo pubblico che elenca tutte le risorse del filesystem, utile in fase di testing. 

La funzioni privata \emph{getParentResource} viene richiamata dalle altre due funzioni, ed è quella che effettua il browsing, restituendo la risorsa che precede quella specificata nel path; ad esempio, si supponga di richiedere una certa operazione da effettuare sulla risorsa \emph{/home/user/resource}, verrà restituita la risorsa padre, ovvero \emph{/home/user/}. Man mano che dalla root scende verso le foglie questa funzione verifica di avere i permessi per poter continuare, permessi che nella comune implementazione Unix sono d'esecuzione, oltre che la risorsa corrente esista e sia effettivamente una Directory. Come parametri d'ingresso richiede un array dove è presente la lista ordinata delle risorse da attraversare per restituire il padre, una variabile dove inserire un eventuale codice di errore, e le credenziali dell'utente.

Si passa ora alle funzione che vengono usate all'interno del codice, e che fanno riferimento alla funzione precedente. La prima è la \emph{getResourcePath}, che viene invocata nel caso si voglia creare una nuova risorsa: in questo caso si prende la risorsa che viene restituita da \emph{getResource}, e si controlla che essa non sia nulla; se poi il nodo non contiene altri vertici uscenti con il nome della risorsa che si vuole creare allora viene ritornato, altrimeni la funziona ha un return nullo. Di seguito è riportato lo pseudocodice:

Per finire è presente la funzione utilizzata dalla maggior parte delle funzioni, la \emph{getResource}, che restituisce il vertice specificato nel path, o null se l'elaborazione ha incontrato problemi. Come funzione è abbastanza elementare, semplicemente chiama la \emph{getParentresource}, verifica se l'utente ha i permessi d'esecuzione sulla directory padre, se si tenta di restituire la risorsa richiesta se questa è presente. In caso di errori restituisce null.

\begin{algorithm}
\caption{Ritorna il padre della risorsa richiesta, null se non è stato possibile determinarlo, in tal caso retValue è settato. L'elemento path[0] è la risorsa root.}
\begin{algorithmic}
\Function{getParentResource}{path, retValue, user, group}
	\If {$path.length=1$}
		\State $retValue \gets EACCESS$
		\State \Return $null$
	\EndIf
	\State $index \gets 1$
	\State $parent \gets root$
	\While {$index+1 < path.leght$ and $parent<>null$}
		\If {$canExecute(parent, user, group)$}
			\State $retValue \gets EACCESS$
			\State \Return null
		\EndIf
		\State $parent \gets parent.follow(path[index])$
		\If {$parent=null$}
			\State $retValue \gets ENOENT$
		\ElsIf {parent.isNotDirectory}
			\State $retValue \gets ENOENT$
			\State $parent \gets null$
		\EndIf
		\State $index++$
	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\caption{Ritorna il padre della risorsa richiesta, null se non è stato possibile determinarlo, in tal caso retValue è settato.}
\begin{algorithmic}
\Function{getResourcePath}{path, retValue, user, group}
	\State $canonicalPath \gets path.split("/")$
	\State $parent \gets getParentResource(canonicalPath, retValue, user, group)$
	\If {$parent=null$}
		\State \Return null
	\EndIf
	\State $resourceName \gets canonicalPath.lastElement$
	\If {$parent.hasOutResource(resourceName)=false$}
		\State \Return parent
	\EndIf
	\State $retvalue \gets EEXIST$
	\State \Return null
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\begin{algorithmic}
\caption{Ritorna la risorsa richiesta, null se non è stato possibile determinarla, in tal caso retValue è settato.}
\Function{getResource}{path, retValue, user, group}
	\State $canonicalPath \gets path.split("/")$
	\State $parent \gets getParentResource(canonicalPath, retValue, user, group)$
	\If {$parent=null$}
		\State \Return null
	\EndIf
	\If {$canExecute(parent, user, group)=false$}
	\State $retValue \gets EACCESS$
		\State \Return null
	\EndIf
	\State $resourceName \gets canonicalPath.lastElement$
	\State $resource \gets parent.follow(resourceName)$
	\If {$resource = null$}
		\State $retvalue \gets ENOENT$
		\State \Return null
	\EndIf
	\State \Return resource
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage

\subsection{Funzioni sul filesystem}
Verranno ora analizzate le funzioni che vanno ad operare materialmente sul database, seguite dalla loro implementazione in pseudocodice.
\subsubsection{getattr}
