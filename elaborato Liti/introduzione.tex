\chapter{Introduction}
The world of the information technology in the 21$^{th}$ century, mainly due to the success of the internet, in particular of the world wide web, has seen the raise of many problems that until now have been ignored, first of all the handle of big data sets.

The classic way to manage data is using an SQL solution, like MySQL, or PostgreSQL, but the truth is that this is not, and it will never can be, \emph{the} solution. Its force, but also its weakness, is the strict theory on which relational databases are based on. I say that this is a pro because a good phase of design can produce a well-formed database, data-consistent and error less. On the other hand this is con, because this theory is not so recent: relational model has been introduced in the 70s, so it's half century old.

This work is not only about databases: it is part of a bigger project whose hit is building a FUSE driver for OrientDB, a multi-model non-relational database.
This in not the whole project, and what will be seen here is how the library to manage informations stored in OrientDB as if they were real files directories or links has been written.

\subsubsection{Chapter 2}
As we will see in this chapter, RDBMS is not the best solution for big complex data storing, mainly due to their expansive join operations and to the lien of using non-structured attributes, while it is still a good solution in non efficiency-critic scenarios.

As each type of task requires a different language (I would never write an operative system in Java or Python, as I would never write a simple script in C or C++), each complex data persisting problem could be well solved using an appropriate solution. This approach is known as \emph{polyglot persistence}.

After this short \emph{excursus} on the noSQL world, will be presented the used database, OrientDB, introducing its main characteristics, such as the possibility of use it as a graph, object or documental database.

\subsubsection{Chapter 3}
Because this is not an isolated work, the purpose of the chapter 3 is to present FUSE to the reader. It is a default kernel module since version 2.6.14 and allows users to create filesystems in their userspace without recompiling kernel, so without administrative privileges. Moreover, FUSE allows to work with its filesystems transparently, using standard commands and programs.

Here will be introduced also the virtual file system concept, that is the kernel layer that allows to not distinguish the different filesystems, and how FUSE interact with it.

\subsubsection{Chapter 4}
This is the most important part, and it's here that the library architecture will be examined in its main parts: how filesystem concepts have been translated into a non-filesystem resource, how data browsing is actuated, how permissions hare handled and how functions are implemented.

A relevant importance in this chapter is given to methods implementation, and, after a short description of what they do is presented their pseudocode. 

\subsubsection{Chapter 5}
In this last chapter the focus is on performances of adopted solutions and on the analysis of how OrientDB can help the developer, and in the end will be presented new possible improvements.